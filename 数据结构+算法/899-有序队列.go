package main

import (
	"fmt"
	"sort"
)
//899. 有序队列
//给定一个字符串 s 和一个整数 k 。你可以从 s 的前 k 个字母中选择一个，并把它加到字符串的末尾。
//返回 在应用上述步骤的任意数量的移动后，字典上最小的字符串 。
//示例 1：
//
//输入：s = "cba", k = 1
//输出："acb"
//解释：
//在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。
//在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。
//示例 2：
//
//输入：s = "baaca", k = 3
//输出："aaabc"
//解释：
//在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。
//在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。
//k=1的场景
//因为每次只能移动第一个字母，因此可能组成的字符串是个有限集，所以只需要移动len(s)-1次，从形成的len(s)个字符串取最小值即可
//
//k=2的场景
//因为可以移动前两位字符，只需要把前两个字符中较小的字符后移，就能得到字符串中最大的字符max1，同理能得到第二大字符max2
//保持max2在字符串的第一位，在不停的调换后，使得max1位于max2后
//同理，在知道第三大字符max3后将max3置于字符串第一位，在不停调换后就能使max2位于max3后，且max1位于max2后
//以此类推，最终能得到一个完全升序的字符串，因此结果就是字符串排序后的结果
//
//k>2的场景
//k>2的场景全都当作k=2处理，必然能得到一个升序字符串，因此结果也是字符串排序后的结果
func orderlyQueue(s string, k int) string {
	//// k==1 时，只能选第一个字母，也就是旋转字符串，取最小值
	if k == 1 {
		ans := s
		for i := 1; i < len(s); i++ {
			s = s[1:] + s[:1]
			if s < ans {
				ans = s
			}
		}
		return ans
	}
	t := []byte(s)
	sort.Slice(t, func(i, j int) bool {
		return t[i] < t[j]
	})
	return string(t)
}
func main() {
	fmt.Println(orderlyQueue("baaca",2))
}